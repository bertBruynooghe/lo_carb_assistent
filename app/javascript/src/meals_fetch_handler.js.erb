import dbConnection from './db_connection'

const mealsPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :index) %>'
const newMealPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :new) %>'

// TODO: this also catches new, show, edit, and this is not what we want in the end.
export const isMealsFetch = r => {
  const { searchParams, pathname } = new URL(r.url)
  const ajax = searchParams.get('ajax')

  return (pathname.indexOf(mealsPath) === 0 && !ajax)
}

const fetchMealsHTML = () => caches.match('<%%= asset_pack_path "meals-index.html.erb" %>')

const fetchNewMealHTML = () => caches.match('<%%= asset_pack_path "meal-form.html.erb" %>')

const fetchMealsJSON = request => {
  return new Promise(resolve =>
    fetch(request).then(resolve).catch(() => new Response([])))
}

const postNewMeal = async (request) => {
  const formData = await request.formData()
  formData.set('meal[client_token]', Math.random() * Number.MAX_SAFE_INTEGER)
  const formHash = {}
  for(const [k,v] of formData) {
    const tokens = k.replaceAll(']', '').split('[')
    tokens.reduce((acc, t, i) => {
      if (!acc[t]) acc[t] = ((tokens.length - 1)) === i ? v : {}
      return acc[t]
    }, formHash)
  }

  // TODO: set a notification about processing => if there is data in the indexedDb
  const transaction = (await dbConnection).transaction('meals', 'readwrite')
  const meals = transaction.objectStore('meals')
  const addRequest = meals.add(formHash.meal)
  const mealId = await new Promise(resolve =>
    addRequest.onsuccess = () => resolve(addRequest.result))
 
  new Promise(async resolve => {

    // we fetch the new page from the backend to have a new session cookie,
    // and the according authenticity token
    const pageResult = await fetch(newMealPath, { credentials: 'include' })
    const pageText = await pageResult.text()
    const authenticityToken = /name=\"authenticity_token\".*value=\"(.*)\"/g.exec(pageText)[1]
    formData.set('authenticity_token', authenticityToken)

    const headers = new Headers(request.headers)
    // next line is necessary to have correct boundaries in the multiform data
    headers.delete('Content-type')

    const newRequest = new Request(request, { body: formData, credentials: 'include', headers })

    const response = await fetch(newRequest)

    const transaction = (await dbConnection).transaction('meals', 'readwrite')
    const meals = transaction.objectStore('meals')
    meals.delete(mealId)

    // TODO: notify the client
    console.log('sync complete')
    resolve(response)
  })

  return Response.redirect(`${mealsPath}/-${formHash.meal.client_token}`, 302)
}

export const fetchMeals = request => {
  const { pathname } = new URL(request.url)
  switch (pathname) {
    case newMealPath: return fetchNewMealHTML(request)
    case mealsPath: return (request.method === 'GET' ? fetchMealsHTML(request) : postNewMeal(request))
    case `${mealsPath}.json`: return fetchMealsJSON(request) 
    default: return fetch(request)
  }
}