import dbConnection from './db_connection'

const mealsPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :index) %>'
const newMealPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :new) %>'

// TODO: this also catches new, show, edit, and this is not what we want in the end.
export const isMealsFetch = r => {
  const { searchParams, pathname } = new URL(r.url)
  const ajax = searchParams.get('ajax')

  return (pathname.indexOf(mealsPath) === 0 && !ajax)
}

const fetchMealsHTML = () => caches.match('<%%= asset_pack_path "meals-index.html.erb" %>')

const fetchNewMealHTML = () => caches.match('<%%= asset_pack_path "meal-form.html.erb" %>')

const fetchMealsJSON = request => {
  return new Promise(resolve =>
    fetch(request).then(resolve).catch(() => new Response([])))
}

const postNewMeal = async (request) => {
  const formData = await request.formData()
  const formHash = {}
  for(const [k,v] of formData) {
    const tokens = k.replaceAll(']', '').split('[')
    tokens.reduce((acc, t, i) => {
      if (!acc[t]) acc[t] = ((tokens.length - 1)) === i ? v : {}
      return acc[t]
    }, formHash)
  }
 
  try {
    // TODO: set a notification about processing => if there is data in the indexedDb
    // TODO: store the data in indexedDb
    const transaction = (await dbConnection).transaction('meals', 'readwrite')
    const meals = transaction.objectStore('meals')
    meals.add(formHash.meal)

    // TODO: redirect to the meals page => we don't have a proper id yet. Negative id to fetch from indexedDb?
    // TODO: fetch the new meal page from backend (with { credentials: 'include' }?)
    const pageResult = await fetch(newMealPath, { credentials: 'include' })
    const pageText = await pageResult.text()
    const test = /name=\"authenticity_token\".*value=\"(.*)\"/g
    const authenticityToken = test.exec(pageText)[1]
    formData.set('authenticity_token', authenticityToken)

    const headers = new Headers(request.headers)
    // next line is necessary to have correct boundaries in the multiform data
    headers.delete('Content-type')

    const newRequest = new Request(request, { body: formData, credentials: 'include', headers })

    return fetch(newRequest)

    // TODO: remove the processing notification
    // TODO: notify the client
  } catch (e) {
    // do nothing here, since we should have caught this already
  }
}

export const fetchMeals = request => {
  const { pathname } = new URL(request.url)
  switch (pathname) {
    case newMealPath: return fetchNewMealHTML(request)
    case mealsPath: return (request.method === 'GET' ? fetchMealsHTML(request) : postNewMeal(request))
    case `${mealsPath}.json`: return fetchMealsJSON(request) 
    default: return fetch(request)
  }
}