import dbConnection from './db_connection'

const mealsPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :index) %>'
const newMealPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :new) %>'

export const isMealsFetch = r => {
  const { searchParams, pathname } = new URL(r.url)
  return (pathname.indexOf(mealsPath) === 0 )
}

const fetchMealsIndexHTML = () => caches.match('<%%= asset_pack_path "meals-index.html.erb" %>')

const fetchMealShowHTML = () => caches.match('<%%= asset_pack_path "meal-show.html.erb" %>')
const fetchMealFormHTML = () => caches.match('<%%= asset_pack_path "meal-form.html.erb" %>')

const fetchMealsJSON = request => {
  return new Promise(resolve =>
    fetch(request).then(resolve).catch(() => new Response([])))
}

const postNewMeal = async (request) => {
  const { random, ceil } = Math
  const formData = await request.formData()

  // next number seems the highest number the database supports for 'integer' 
  const maxDbInteger = 0x7FFFFFFF
  formData.set('meal[client_token]', ceil(random() * maxDbInteger))
  const formHash = {}
  for(const [k,v] of formData) {
    const tokens = k.replaceAll(']', '').split('[')
    tokens.reduce((acc, t, i) => {
      if (!acc[t]) acc[t] = ((tokens.length - 1)) === i ? v : {}
      return acc[t]
    }, formHash)
  }

  // TODO: set a notification about processing => if there is data in the indexedDb
  const transaction = (await dbConnection).transaction('meals', 'readwrite')
  const meals = transaction.objectStore('meals')
  const addRequest = meals.add(formHash.meal)
  const mealId = await new Promise(resolve =>
    addRequest.onsuccess = () => resolve(addRequest.result))
 
  new Promise(async resolve => {

    // we fetch the new page from the backend to have a new session cookie,
    // and the according authenticity token
    const pageResult = await fetch(newMealPath, { credentials: 'include' })
    const pageText = await pageResult.text()
    const authenticityToken = /name=\"authenticity_token\".*value=\"(.*)\"/g.exec(pageText)[1]
    formData.set('authenticity_token', authenticityToken)

    const headers = new Headers(request.headers)
    // next line is necessary to have correct boundaries in the multiform data
    headers.delete('Content-type')

    const newRequest = new Request(request, { body: formData, credentials: 'include', headers })

    const response = await fetch(newRequest)

    const transaction = (await dbConnection).transaction('meals', 'readwrite')
    const meals = transaction.objectStore('meals')
    meals.delete(mealId)

    // TODO: notify the client
    // TODO: we should at least know the id of the newly created meal. and pass it somewhere?
    console.log('sync complete')
    resolve(response)
  })

  return Response.redirect(`${mealsPath}/-${formHash.meal.client_token}`, 302)
}

export const fetchMeals = request => {
  const { pathname } = new URL(request.url)
  switch (pathname) {
    case newMealPath: return fetchMealFormHTML(request)
    case mealsPath: return (request.method === 'GET' ? fetchMealsIndexHTML(request) : postNewMeal(request))
    case `${mealsPath}.json`: return fetchMealsJSON(request) 
    default:
      if (new RegExp(`${mealsPath}\/-?[0-9]+$`, 'gm').test(pathname)) return fetchMealShowHTML(request)
      return fetch(request)
  }
}