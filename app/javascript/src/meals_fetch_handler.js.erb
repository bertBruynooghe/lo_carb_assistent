const mealsPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :index) %>'
const newMealPath = '<%= Rails.application.routes.path_for(controller: :meals, action: :new) %>'

// TODO: this also catches new, show, edit, and this is not what we want in the end.
export const isMealsFetch = r => {
  const { searchParams, pathname } = new URL(r.url)
  const ajax = searchParams.get('ajax')

  return (r.method === 'GET' && pathname.indexOf(mealsPath) === 0 && !ajax)
}

const fetchMealsHTML = async (request) => {
  const newRequest = new Request(`${mealsPath}?ajax=true`, { ...request, mode: 'cors' } )

  // get the response from the cache, this should never fail
  const oldResponse = await caches.match(newRequest)
  
  fetch(newRequest).then(async (response) => {
    const cache = await caches.open(newRequest.url)
    cache.put(newRequest, response) 
  }).catch(e => {
    // couldn't get the HTML, so we're not updating the cache
  })
  
  return oldResponse
}

const fetchNewMealHTML = async (request) => {
  // get the response from the cache, this should never fail
  // TODO: not 100% sure why the mode has to change from 'navigate' to 'cors'
  const newRequest = new Request(request.url, { ...request, mode: 'cors' } )

  const oldResponse = await caches.match(newRequest)
  
  fetch(request).then(async (response) => {
    const cache = await caches.open(newRequest.url)
    cache.put(newRequest, response) 
  }).catch(e => {
    // couldn't get the HTML, so we're not updating the cache
  })
  
  return oldResponse
}

const fetchMealsJSON = request => {
  return new Promise(resolve =>
    fetch(request).then(resolve).catch(() => new Response([])))
}

export const fetchMeals = request => {
  const { pathname } = new URL(request.url)
  switch (pathname) {
    case newMealPath: return fetchNewMealHTML(request)
    case mealsPath: return fetchMealsHTML(request)
    case `${mealsPath}.json`: return fetchMealsJSON(request)
    default: return fetch(request)
  }
}