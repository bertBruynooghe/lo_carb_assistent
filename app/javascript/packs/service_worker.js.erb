const CACHE_VERSION = 'v1'
const CACHE_NAME = CACHE_VERSION + ':sw-cache-'

// mmm, it looks like the caches don't get updated once they're changed.
// I guess the version should be a hash so it updates whenever one of the cached files changes
const CACHES = [
  // make sure service_worker.js is not required by application.js
  // if you want to reference application.js from here
  '<%= ActionController::Base.helpers.asset_path "application.js" %>',
  '<%= ActionController::Base.helpers.asset_path "application.css" %>',
  '/offline.html',
]

const dbOpenRequest = self.indexedDB.open('nutrientsCalculator', 1)
dbOpenRequest.onupgradeneeded = ({ target: { result: db }, oldVersion }) => {
  switch (oldVersion) { // existing db version
    case 0:
      const nutrients = db.createObjectStore('nutrients', { keyPath: '_id', autoIncrement: true })
      nutrients.createIndex('id_idx', 'id', { unique: true })
  }
}

const dbConnection = new Promise((resolve, reject) => {
  dbOpenRequest.onerror = reject
  dbOpenRequest.onsuccess = ({ target: { result: db } }) => {
    db.onerror = ({ target: { errorCode } }) => console.error('Database error: ' + errorCode)
    resolve(db)
  }
})

function onInstall(e) {
  console.log('[ServiceWorker]', 'Installing!', e)
  e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(CACHES)))
}

function onActivate(e) {
  console.log('[ServiceWorker]', 'Activating!', e)
  e.waitUntil(
    caches.keys().then(keys =>
      // remember that caches are shared across the whole origin
      Promise.all(
        keys.filter(key => key.indexOf(CACHE_VERSION) !== 0)
          .map(key => caches.delete(key)))))
}

const offlineHandler = async (request) => {
  // if it fails, try to return request from the cache
  const response = await caches.match(request)
  if (response) return response
  // if not found in cache, return default offline content for navigate requests
  if (request.mode === 'navigate' ||
    (request.method === 'GET' && request.headers.get('accept').includes('text/html'))) {
    console.log('[ServiceWorker]', 'Fetching offline content')
    return caches.match('/offline.html')
  }
}

const fetchNutrients = async request => {
  const searchString = new URL(request.url).searchParams.get('q[name_cont]').toLowerCase()

  const requestClone = new Request(nutrientsUrl, request)
  const allNutrientsResponse = await fetch(requestClone)
  const json = await allNutrientsResponse.clone().json()
  const transaction = (await dbConnection).transaction('nutrients', 'readwrite')
  const nutrients = transaction.objectStore('nutrients')
  await new Promise(resolve => nutrients.clear().onsuccess = resolve)
  await Promise.all(json.map(nutrient => new Promise(resolve => nutrients.add(nutrient).onsuccess = resolve)))
  const filtered = json.filter(nutrient => nutrient.name.toLowerCase().indexOf(searchString) >= 0)
  console.log('x', filtered)
  return new Promise(resolve => resolve(new Response(JSON.stringify(filtered), allNutrientsResponse)))
}

const nutrientsUrl = location.origin + '<%= Rails.application.routes.url_helpers.nutrients_path %>'

const isNutrientFetch = r => {
  const acceptHeader = r.headers.get('accept')
  return r.method === 'GET' && r.url.indexOf(nutrientsUrl) === 0 && acceptHeader && acceptHeader.includes('application/json')
}  // also check if request is json request

// Borrowed from https://github.com/TalAter/UpUp
async function onFetch(e) {
  const result = isNutrientFetch(e.request) 
    ? fetchNutrients(e.request)
    : fetch(e.request).catch(offlineHandler)
  
  e.respondWith(result)
}

self.addEventListener('install', onInstall)
self.addEventListener('activate', onActivate)
self.addEventListener('fetch', onFetch)
